import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

class KlassBuilder {

  Map<String, Klass> klassMap = new HashMap<>();

  public static enum RelationType {
    ASSOCIATION, DASSOCIATION, AGGREGATION, DAGGREGATION, DECOMPOSITION, DDECOMPOSITION, DEPENDENCY, DDEPENDENCY
  }

  public static enum AccessModifyer {
    PUBLIC("+"),
    PRIVATE("-"),
    PROTECTED("#"),
    DEFAULT("");

    private final String nType;

    AccessModifyer(String type) {
      this.nType = type;
    }

    public String getType() {
      return this.nType;
    }
  }

  class Klass {

    public ArrayList<Attribute> attributesL;
    public ArrayList<Method> methodsL;
    public ArrayList<String> extendsL; //key for the KlassMap
    public ArrayList<String> implementsL; //key for the KlassMap
    public String name;

    public Klass(String n) {
      this.name = n;
    }

    public void addAttribute(Attribute a) {
      this.attributesL.add(a);
    }

    public void addMethod(Method m) {
      this.methodsL.add(m);
    }

    public void addExtends(String klassKey) {
      this.extendsL.add(klassKey);
    }

    public void addImplements(String klassKey) {
      this.implementsL.add(klassKey);
    }
  }

  class Paramether {

    public String name;
    public String type;

    Paramether(String n, String t) {
      this.name = n;
      this.type = t;
    }
  }

  class Method {

    public String name;
    public String returnType;
    public AccessModifyer modifyer;
    public boolean isStatic;
    public ArrayList<Paramether> paramethers;

    void addParamether(Paramether p) {
      paramethers.add(p);
    }

    Method(String n, String r, AccessModifyer m, boolean s) {
      this.name = n;
      this.returnType = r;
      this.modifyer = m;
      this.isStatic = s;
    }
  }

  class Attribute {

    public String name;
    public String returnType;
    public AccessModifyer modifyer;
    public boolean isStatic;

    Attribute(String n, String r, AccessModifyer m, boolean s) {
      this.name = n;
      this.returnType = r;
      this.modifyer = m;
      this.isStatic = s;
    }
  }
}

COMPILER JTD2DOT

KlassBuilder builder = new KlassBuilder();

CHARACTERS

lowerletter = 'a'..'z'.
upperletter = 'A'..'Z'.

TOKENS

lowerword_c = lowerletter{upperletter|lowerletter}.
upperword_c = upperletter{upperletter|lowerletter}.

COMMENTS FROM "/*" TO "*/"

IGNORE '\n'+'\t'

PRODUCTIONS

JTD2DOT = Definition{Definition}.

// Definitions
Definition = ClassDefinition | InterfaceDefinition.
ClassDefinition = "class" ClassName (. KlassBuilder.Klass clazz = builder.klassMap.put(t.val, null); .) ["extends" ClassName{"," ClassName}] ["implements" ClassName{"," ClassName}]"{" {ClassEntity} "}".
InterfaceDefinition = "interface" ClassName ["extends" ClassName]"{" {InterfaceEntity} "}".

// Super Entities
ClassEntity = [Modifyers] Especializer.
InterfaceEntity = [Modifyers] (CanonicalType|VoidType) EntityName MethodInterfaceCompletition.

// Especializers
Especializer = FunctionEspecializer | AnomalousEspecializer.
FunctionEspecializer = VoidType EntityName MethodCompletition.
AnomalousEspecializer = CanonicalType EntityName (MethodCompletition | AttributeCompletition).

// Methods and Attributes
MethodInterfaceCompletition = "("[CanonicalType EntityName {"," CanonicalType EntityName}] ")" ";".
MethodCompletition = "("[CanonicalType EntityName {"," CanonicalType EntityName}] ")" "{" "}" [";"].
AttributeCompletition = ";".

// Fetched Entities
CanonicalType = UpperName | LowerName.
VoidType = "void".
ClassName = UpperName.
EntityName = (UpperName|LowerName).

// Generic Rules
Modifyers = AccessModifyer[ScopeModifyer] | ScopeModifyer[AccessModifyer].
UpperName = upperword_c.
LowerName = lowerword_c.
AccessModifyer = "public" | "protected" | "private".
ScopeModifyer = "static".

RelationType<out KlassBuilder.RelationType type> (. type = null; .) =
"association" (. type = KlassBuilder.RelationType.ASSOCIATION; .)
|"dassociation"(. type = KlassBuilder.RelationType.DASSOCIATION; .)
|"aggregation"(. type = KlassBuilder.RelationType.AGGREGATION; .)
|"daggregation"(. type = KlassBuilder.RelationType.DAGGREGATION; .)
|"decomposition"(. type = KlassBuilder.RelationType.DECOMPOSITION; .)
|"ddecomposition"(. type = KlassBuilder.RelationType.DDECOMPOSITION; .)
|"dependency"(. type = KlassBuilder.RelationType.DEPENDENCY; .)
|"ddependency"(. type = KlassBuilder.RelationType.DDEPENDENCY; .).


END JTD2DOT.
